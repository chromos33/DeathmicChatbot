"use strict"; function _instanceof(t, e) { return null != e && "undefined" != typeof Symbol && e[Symbol.hasInstance] ? !!e[Symbol.hasInstance](t) : t instanceof e } function _typeof(t) { return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function _classCallCheck(t, e) { if (!_instanceof(t, e)) throw new TypeError("Cannot call a class as a function") } function _defineProperties(t, e) { for (var n = 0; n < e.length; n++) { var o = e[n]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o) } } function _createClass(t, e, n) { return e && _defineProperties(t.prototype, e), n && _defineProperties(t, n), t } function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && _setPrototypeOf(t, e) } function _setPrototypeOf(t, e) { return (_setPrototypeOf = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function _createSuper(t) { var e = _isNativeReflectConstruct(); return function () { var n, o = _getPrototypeOf(t); if (e) { var r = _getPrototypeOf(this).constructor; n = Reflect.construct(o, arguments, r) } else n = o.apply(this, arguments); return _possibleConstructorReturn(this, n) } } function _possibleConstructorReturn(t, e) { return !e || "object" !== _typeof(e) && "function" != typeof e ? _assertThisInitialized(t) : e } function _assertThisInitialized(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function _isNativeReflectConstruct() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch (t) { return !1 } } function _getPrototypeOf(t) { return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var StreamsubAddComponent = function (t) { _inherits(n, React.Component); var e = _createSuper(n); function n(t) { var o; return _classCallCheck(this, n), (o = e.call(this, t)).handleClick = o.handleClick.bind(_assertThisInitialized(o)), o.handleChange = o.handleChange.bind(_assertThisInitialized(o)), o.state = { Options: [], Value: 0 }, o } return _createClass(n, [{ key: "componentWillMount", value: function () { var t = this, e = new XMLHttpRequest; e.open("GET", "/User/SubscribableStreamsData", !0), e.onload = function () { t.setState({ Options: JSON.parse(e.responseText) }) }, e.send() } }, { key: "handleClick", value: function (t) { if (this.state.Value > 0) { var e = this, n = new XMLHttpRequest; n.open("GET", "/User/AddSubscription?streamid=" + this.state.Value, !0), n.onload = function () { window.dispatchEvent(new Event("updateTable")); var t = []; e.state.Options.forEach(function (n) { n.StreamID != e.state.Value && t.push(n) }), e.setState({ Options: t }) }, n.send() } } }, { key: "handleChange", value: function (t) { this.setState({ Value: t.target.value }) } }, { key: "render", value: function () { if (this.state.Options.length > 0) { var t = 0, e = this.state.Options.map(function (e) { return t++, React.createElement("option", { key: t, value: e.StreamID }, e.Name) }); return React.createElement("div", null, React.createElement("select", { onChange: this.handleChange }, React.createElement("option", null, "Auswählen"), e), React.createElement("button", { onClick: this.handleClick, className: "btn btn-default" }, "Subscription hinzufügen")) } return null } }]), n }();