"use strict"; function _instanceof(t, e) { return null != e && "undefined" != typeof Symbol && e[Symbol.hasInstance] ? !!e[Symbol.hasInstance](t) : t instanceof e } function _typeof(t) { return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function _classCallCheck(t, e) { if (!_instanceof(t, e)) throw new TypeError("Cannot call a class as a function") } function _defineProperties(t, e) { for (var r = 0; r < e.length; r++) { var n = e[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } function _createClass(t, e, r) { return e && _defineProperties(t.prototype, e), r && _defineProperties(t, r), t } function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && _setPrototypeOf(t, e) } function _setPrototypeOf(t, e) { return (_setPrototypeOf = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function _createSuper(t) { var e = _isNativeReflectConstruct(); return function () { var r, n = _getPrototypeOf(t); if (e) { var o = _getPrototypeOf(this).constructor; r = Reflect.construct(n, arguments, o) } else r = n.apply(this, arguments); return _possibleConstructorReturn(this, r) } } function _possibleConstructorReturn(t, e) { return !e || "object" !== _typeof(e) && "function" != typeof e ? _assertThisInitialized(t) : e } function _assertThisInitialized(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function _isNativeReflectConstruct() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch (t) { return !1 } } function _getPrototypeOf(t) { return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var Row = function (t) { _inherits(r, React.Component); var e = _createSuper(r); function r(t) { return _classCallCheck(this, r), e.call(this, t) } return _createClass(r, [{ key: "render", value: function () { var t = this; if (this.props.Columns.length > 0) { var e = 0, r = this, n = this.props.Columns.map(function (n) { e++; var o = t.props.ColumnTypes[n.ReactComponentName]; return React.createElement(o, { Sort: r.props.Sort, key: e, id: e, data: n }) }); return React.createElement("tr", null, n) } return React.createElement("tr", null, "ERROR") } }]), r }();