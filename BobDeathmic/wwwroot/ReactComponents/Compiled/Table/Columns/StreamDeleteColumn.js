"use strict"; function _instanceof(e, t) { return null != t && "undefined" != typeof Symbol && t[Symbol.hasInstance] ? !!t[Symbol.hasInstance](e) : e instanceof t } function _typeof(e) { return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } function _classCallCheck(e, t) { if (!_instanceof(e, t)) throw new TypeError("Cannot call a class as a function") } function _defineProperties(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } function _createClass(e, t, n) { return t && _defineProperties(e.prototype, t), n && _defineProperties(e, n), e } function _inherits(e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && _setPrototypeOf(e, t) } function _setPrototypeOf(e, t) { return (_setPrototypeOf = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e })(e, t) } function _createSuper(e) { var t = _isNativeReflectConstruct(); return function () { var n, r = _getPrototypeOf(e); if (t) { var o = _getPrototypeOf(this).constructor; n = Reflect.construct(r, arguments, o) } else n = r.apply(this, arguments); return _possibleConstructorReturn(this, n) } } function _possibleConstructorReturn(e, t) { return !t || "object" !== _typeof(t) && "function" != typeof t ? _assertThisInitialized(e) : t } function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function _isNativeReflectConstruct() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch (e) { return !1 } } function _getPrototypeOf(e) { return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) })(e) } var StreamDeleteColumn = function (e) { _inherits(n, React.Component); var t = _createSuper(n); function n(e) { var r; return _classCallCheck(this, n), (r = t.call(this, e)).handleDeleteClick = r.handleDeleteClick.bind(_assertThisInitialized(r)), r.handleCancelClick = r.handleCancelClick.bind(_assertThisInitialized(r)), r.handleToggleDeleteForm = r.handleToggleDeleteForm.bind(_assertThisInitialized(r)), r.state = { Open: !1 }, r } return _createClass(n, [{ key: "handleCancelClick", value: function (e) { this.setState({ Open: !1 }) } }, { key: "handleDeleteClick", value: function (e) { var t = new XMLHttpRequest; t.open("GET", "/Stream/DeleteStream?streamID=" + this.props.data.StreamID, !0), t.onload = function () { !1 !== t.responseText && (this.setState({ Open: !0 }), window.dispatchEvent(new Event("updateTable"))) }, t.send() } }, { key: "handleToggleDeleteForm", value: function (e) { this.setState({ Open: !0 }) } }, { key: "render", value: function () { return void 0 !== this.props.data ? this.state.Open ? React.createElement("td", null, this.props.data.Text, React.createElement("div", { className: "shadowlayer" }), React.createElement("div", { className: "statictest grid column-4 row-3" }, React.createElement("h1", { className: "deleteText" }, "Bist dir sicher den Stream löschen zu wollen?"), React.createElement("span", { onClick: this.handleDeleteClick, className: "btn btn_primary deletebtn" }, "Endgültig löschen"), React.createElement("span", { onClick: this.handleCancel, className: "btn btn_primary canceldeletebtn" }, "Abbrechen"))) : React.createElement("td", { className: "pointer", onClick: this.handleToggleDeleteForm }, this.props.data.Text) : null } }]), n }();